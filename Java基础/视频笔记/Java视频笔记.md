# Java视频笔记

## 第7章 方法

+ main是由JVM调用的。
+ 方法名在标识符命名规范当中，要求首字母小写，后面每个单词首字母大写。

* jvm内存结构：方法区（由classloader将xxx.class字节文件装到jvm当中，也就是方法中存储代码片段）、堆区、栈区
## 第8章 面向对象
* 属性在代码上是以变量形式存在（描述状态），因为属性对应数据
* java中除了基本数据类型之外，剩下的数据类型都是引用。**基本数据类型变量存的是数据本身，而引用类型变量存的是保存数据的空间地址**
* 带static的方法用类名调，不带的用new实例去调用方法。
* 不论什么方法，实例、构造、静态方法等都会压栈。堆存实例变量，栈存局部变量。
* 栈：方法只要执行，就会压栈。堆：new出来的对象都在堆中。垃圾回收器主要控制该区变量。方法区：类的信息，字节码、代码片段、静态变量。
方法的代码片段放在方法区，但是方法执行过程当中需要内存在栈中。
* static静态变量，在类加载时初始化，不需要new对象，静态变量的空间就开出来了。**栈：局部变量、堆：实例变量（对象级别）、方法区：静态变量（类级别）。** 静态的属性、方法实际都是类名在调用。
* 默认封装应该是public
* 工具类一般的方法都是静态的。
* 静态代码块在类加载时执行，并且只执行一次，自上而下，而且在main方法之前执行。一般静态代码块可以在类加载时记录日志。
* 实例块在构造方法之前执行。
* this是指向自身实例的指针
* **由于main是静态方法，所以main中是无法直接访问类下的实例方法以及实例变量**，this不能出现在static方法中！！！,**因为静态方法不会默认传参this**
* java方法中没有缺省参数设在默认值的方法。
* this(形参列表),在构造方法中可以直接调用构造方法。一般用于代码复用。注：this()的调用只能出现在构造方法的第一行,表示当前构造方法调用本类其他构造方法。

## 第9章 继承

+ 封装
  - **private 　在当前类中可访问**
  - **default    在当前包内和访问**
  - **protected  在当前类和它派生的类中可访问**
  - **public     公众的访问权限，谁都能访问**

+ c++继承与java继承区别：**在c++中，重载不会发生在基类与派生类之间，派生类中的同名函数都会将基类中的同名函数隐藏（将在下边说明隐藏）掉，而不会是重载关系。当你通过派生类对象调用该同名函数时，只能访问派生类的该函数，如果硬要访问基类的该函数，则需要在函数名前加上类作用域，在java中子类会将父类中的方法继承过来，子类中同名方法会和父类中的同名方法要么是重载关系，要么是覆盖关系，要么就错误（比如同名同参却是不同的返回类型！）**

+ 对于虚函数(用virtual修饰的)，如果基类中有一个虚函数，派生类中同样有一个同名同参的函数（那么该函数将自动虚化）， 那么其返回值一定要和基类的虚函数的返回值相同！否则隐藏失败！

  但是在java中请记住这样的原则：非静态方法只能由（或被）非静态方法覆盖！静态方法只能由（或被）非静态方法覆盖！抽象方法必须在具体类中被覆盖！最终方法(带关  键字final的方法)不能被覆盖！

+ java不支持多继承，c++可实现多继承。虽然不能多继承，单可以间接继承。

+ 继承除构造方法无法继承之外，剩下都可以继承，但是私有的属性无法在子类中直接访问。父类中private修饰不能在子类中直接访问。可以通过间接的手段来访问。

+ java默认继承上帝类Object

+ 关键字extend

+ 继承父类修改子类也需要修改，所以继承会增强代码之间的耦合度。

+ **当源码当中一个方法以";"结尾，并且修饰符列表中有"native"关键字，表示底层调用C++写的dll程序(dll动态链接库)。

+ Object类

  方法：

  + equal(Object obj)
  + clone()
  + toString()，返回：ClassName@addr(哈希运算后的地址)，注println(引用)会自动调用toString方法

## 第10章 方法覆盖与多态

+ 方法覆盖即将继承对象的方法进行重写，并将继承的方法覆盖掉。当子类进行了方法覆盖后，不会调用继承方法，而一定会调用覆盖后的方法。

+ **方法重写的条件**：1、继承关系2、返回、方法名、参列所有一致（好像返回值在继承时可以不同，**有待解释**）。（而如果形参列表不同不是重写而是重载）3、访问权限不能更低，可以更高。（**有待解释**）4、重写方法不能比之前的方法抛出更多的异常。（**有待解释**）

  注意：1、方法覆盖与属性无关，只与方法有关。2、私有方法无法覆盖。3、构造方法不能被继承，所以构造方法也不能被覆盖。4、覆盖指针对实例方法，对静态方法覆盖无意义。

  **大多类的toString()都需要重载**

+ **点前只能是引用、类名**

+ 向上转型与向下转型
  向上(upcasting)：子—>父（自动类型转换）：Animal a = new Cat();
  向下(downcasting)：父—>子（强制类型转换，需要加强制类型转换符）Cat c = (Cat)a;
  注：无论是向上还是向下，两种类型必须有继承关系，没有继承关系报错。

+ 父类引用允许指向子类对象(向上转型)

+ 多态
  程序编译阶段、运行阶段：
  对于编译器，编译器只知道a2的类型是Animal，所以编译器在检查语法的时候，会去Animal.class字节码中寻找move方法，找到了绑定上move()方法，编译通过，静态绑定成功。(编译阶段属于静态绑定)
  运行阶段：实际上在堆内存中创建的java对象是cat对象，所以move的时候，真正参与move的对象是一只猫，所以运行阶段会动态执行cat对象的move方法，这个过程属于运行阶段绑定。(运行阶段绑定属于动态绑定)
  **多态：父类引用指向子类对象，包括编译阶段绑定父类方法，运行阶段动态绑定子类对象方法。  多种形态。**

+ 什么时候必须向下转型？
  当需要访问子类对象特有方法必须向下转型。 

+ 向下转型的风险、
  即父类指向了一子类，但通过向下转型转为另一子类。此时编译器不报错，而运行阶段抛出异常：java.lang.ClassCastException:**重要异常还有java.lang.NullPointerException**。

+ 如何避免ClassCastException异常的发生
  **instanceof运行阶段动态判断**
  第一：instanceof可以在运行阶段动态判断引用指向的对象类型
  第二：instance的语法：（引用 instanceof 类型）
  第三：instanceof运算符的运算结果只能是true/false
  第四：c是一个引用，c变量保存了内存地址指向堆中对象。则（c instanceof Cat）为true表示：c引用指向堆中对象是一个Cat
  所以**当类型向下转型时要用instanceof**

+ 多态在开发中的作用

  降低程序耦合度，提高扩展力。方便扩展，在面向父类情况下编程更加易于扩展。
  
+ 私有方法无法覆盖，方法覆盖只针对实例方法，静态方法覆盖无意义。因为静态方法虽然可以引用.但实际与引用无关，只与类相关。**多态与对象有关，静态方法不需要对象**

+ 同一文件中，不能有多于一个public声明的类出现，可以将其中一个public去掉，即不加任何修饰符，通常称为“默认访问模式”，在该模式下，这个类只能被同一个包中的类访问或引用，这一访问特性又称包访问性。

+ 由于private方法被自动认为是final方法，而且对子类即Derived是屏蔽的，根本不能被重载和重写，所以此时Derived类里面的"public void f()"方法属于一个全新的方法，对基类的引用po来说也不可见，调用的只能是"private void f()"。

  结论：只有非private方法才能被真正的覆盖，虽然上面的例子编译器不报错，但是结果并不是我们期望的。对于子类来说，最好不要采用和基类private方法相同的名字做方法名。

  （**以上有待补充**）

+ 子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。可以继承，只是无法访问到而已。

+ 总结：私有不能覆盖，静态不谈覆盖

+ 对于相同的返回类型这一点（重写）

  返回类型是基本数据来说，必须一致

  返回类型是引用类型来说，重写之后返回值类型可以更小（即返回子类是可以的）**意义不大，一般不这么做**

## 第11章 super

super(实参)：初始化当前对象的父类的特在。

super关键字代表就是当前对象那部分父类特征。虽然是继承，但完成继承后属性以属于该对象。

把super当作命名空间（自己猜想，不知道是否正确。）

+ super与this

  this:能出现在实例方法和构造方法中。语法是this.和this()，不出现在静态方法中，this()只能出现在构造方法第一行，通过当前构造方法去调用**本类**中其他的构造方法，目的是代码复用。

  super:能出现在实例方法和构造方法中。语法是super.和super()，不出现在静态方法中，this()只能出现在构造方法第一行，通过当前构造方法去调用**父类**的构造方法，目的是创建子类对象先初始化父类特征。

+ super()表示子类的构造方法调用父类的构造方法。

+ 当一个构造方法第一行：

  即没有this()、super()时默认有一个super();所以要保证父类无参构造存在。

+ 注：this()\super()不能同时存在，他们只能在构造函数的第一行。

+ java中不管new什么对象，最后Object的无参构造方法一定执行。（object构造在栈顶）

+ 构造方法执行过程中一连串调用了父类的构造方法，父类的构造方法继续调用父类构造方法。但实际只创建了一个对象。

+ super什么时候不能省略，在需要区分子父类同名属性或方法时，若不加super，同名属性或方法默认调用子类的。还有在子类想要调用父类特征时需要用super.

+ super不指向任何对象，仅仅代表当前对象的那一块父类特征。

+ IDEA快捷键
  psvm、sout、
  ctrl+y ： 删除一行
  alt+左右：左侧列表展开,也可切窗口
  alt+insert:任何新增
  ctrl + shift + F12:窗口变大，变小
  alt+标号:切换窗口
  ctrl+p:可以查看函数穿的参数

## 第十二章 final关键字

**final修饰东西都不变**

* 可修饰变量、类、方法，表示最终的。

  当修饰类时，该类不可被继承。（**什么时候用有待补充**）

  当修饰方法时，该方法不可被覆盖（重写）。

  final不控制调用的问题，表示的是能不能再改变。

  当修饰局部变量时，一旦赋值后不能再更改。即final修饰的变量只能赋值一次。**对于引用也是同理**

  final修饰引用：该引用永远只能指向一个对象。但该对象的值可以修改

  当修饰实例变量（实例变量不赋值会默认赋初值），当被final修饰时，实例变量必须手动赋值。（手动赋值可以再构造函数中赋值）

  final修饰实例变量时，应该在final前加static将其存储再方法区，节省空间。**static final联合修饰变量即为常量**，常量是不能变的静态变量，在类加载时初始化。

## 第十三章 抽象类与接口

### 抽象类（和c++的virtual一样）

+ 当作virtual类理解即可无法实例化。抽象类也是引用数据类型。抽象类的子类还可以是抽象类。

+ 语法：[修饰符] abstract class 类名{类体}

+ final与abstract无法联合使用。

+ 抽象类有构造方法，供子类使用，抽象类new不出来。

+ 抽象方法，eg:public abstract void func();

  抽象方法没有方法体，专供子类重写的。  抽象方法必须在抽象类中。

+ 非抽象类继承抽象类，必须将抽象方法实现（重写）。 

+ (面试题) java语言中凡是没有方法体的方法不一定就是抽象方法。

  object类中有很多没有方法体的方法，且又不是抽象方法。

  ```java
  public native int hashCode();
  ```

  这个方法底层调用了C++写的动态链接库程序。前面修饰符列表中有一个native，表示调用JVM本地程序。

+ 抽象的类里可以有抽象的方法和非抽象的方法 抽象类中的非抽象方法往往是抽象类所有未来子类都具有的,且不会因为子类的不同而具体实现不同的方法

### 接口

接口离不开多态，编程要面向抽象编程。接口可以解耦合，解开接口的调用者与实现者之间的耦合。

+ 接口是引用数据类型，编译后还是class，接口完全抽象（抽象类半抽象），或者可以说是特殊的抽象类
+ 语法:[修饰符] interface 接口名{}
+ 接口支持多继承
+ 接口只包含两个部分，一部分：常量，一部分：抽象方法
+ 接口所有元素都是public修饰，接口类中所有方法均只能为抽象方法，且public abstract 可以省略。接口中的常量可以省略 public static final
+ is a、has a、like a
  is a：表示继承关系
  has a：表示“关联关系”，关联关系通常以属性的形式存在。
  like a：表示实现关系，实现关系通常是类实现接口。
+ 抽象类和接口的区别
  抽象类是半抽象的，接口是完全抽象的。抽象类中有构造方法，接口中没有构造方法。接口和接口之间支持多继承，类和类之间只有单继承。一个类可以同时实现多接口，一个抽象类只能继承一个类。接口中只允许出现常量和抽象方法。**一般接口使用的多一些，接口一般对行为进行抽象**

## 第十四章

### package和import

* 包机制的作用是方便程序管理，不同功能的类分别存放在不同包下。
* package是关键字，后面加报名。例如：package com.bjpower.javase.chapter17;
  **注：package语句只能出现在java源代码第一行**
* 对于带有package的java程序，类名会有变化，eg：com.bjpowernode.javase.chapter17.HelloWorld
  编译命令 javac -d . HelloWorld.java
  **类名会自动带上包名**
* 同一包下，包名可以省了。不同包下，利用import语句把需要类导入。imort只能在package下，class声明前。
* lang包下直接子类不需要导入，但子包需要导入。
* import java.util.*，不会导致效率低，因为编译器会自动把 *替换成类名

### 访问控制权限

public：本类、同包、子类、任意
protected：本类、同包、子类（不同包）
default：本类、同包
private：本类

* 属性（4个均可）、方法（4个均可）、类（public和默认）、接口（public和默认）

### Object类

* 目前需要知道的几个方法：
  protected Object clone()    /负责对象克隆
  int hashCode()            /获取对象哈希值
  boolean equals(Object obj)      /判断两个对象是否相等
  String toString()                       /将对象转换成字符串形式(**一般自己写的类建议重写**)
  protected void finalize()       /垃圾回收器负责调用
* equals方法
  设计目的：用来判断两个对象是否相等。根据实际需要可以判断是否需要重写。注：java没有符号重载，所以‘==’是不可判断对象是否相等，**例如‘==’无法判断string是否相等**。默认的equal是用‘==’判断对象是否相等。**注：重写的时候除修饰符可以不同（只能大，不能小），其余都得一样否则就是重载**
   null instanceof 都是false
  结论：基本数据用‘==’判断相等，引用数据用equal方法判断相等。



